# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2022-12-18T07:05:40+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import AnyUrl, BaseModel, EmailStr, Field, confloat, conint, constr


class APIToken(BaseModel):
    name: Optional[constr(max_length=50)] = Field(
        None,
        description='A free-form name for the API key. Need not be unique. 50 characters max.',
    )
    prefix: str
    expiry_date: Optional[datetime] = Field(
        None,
        description='Once API key expires, clients cannot use it anymore.',
        title='Expires',
    )
    created: datetime


class APITokenCreateResponse(BaseModel):
    api_key: APIToken
    key: str


class APITokenRollResponse(BaseModel):
    api_key: APIToken
    key: str


class Action(BaseModel):
    id: int
    actor: str
    verb: constr(max_length=255)
    action_object: str
    target: str
    public: Optional[bool] = None
    description: Optional[str] = None
    timestamp: Optional[datetime] = None


class Kpi(Enum):
    total_revenue = 'total_revenue'


class Status(Enum):
    running = 'running'
    completed = 'completed'
    failed = 'failed'


class BacktestSubstitutionMulti(BaseModel):
    new_plan: str
    original_plans: List[str]


class Status1(Enum):
    running = 'running'
    completed = 'completed'
    failed = 'failed'


class BacktestSummary(BaseModel):
    backtest_name: constr(max_length=100)
    start_date: date
    end_date: date
    time_created: Optional[datetime] = None
    kpis: Optional[Dict[str, Any]] = None
    status: Optional[Status1] = None
    backtest_id: Optional[constr(max_length=100)] = None


class Operator(Enum):
    isin = 'isin'
    isnotin = 'isnotin'


class CategoricalFilter(BaseModel):
    property_name: constr(max_length=100)
    operator: Operator
    comparison_value: List[str]


class Status2(Enum):
    success = 'success'


class ConfirmIdemsReceived(BaseModel):
    status: Status2
    ids_not_found: List[str]


class Status3(Enum):
    failure = 'failure'


class ConfirmIdemsReceivedFailure(BaseModel):
    status: Status3
    error: str


class ConfirmIdemsReceivedRequest(BaseModel):
    idempotency_ids: List[str]
    number_days_lookback: Optional[int] = 30
    customer_id: Optional[str] = None


class PaymentProvider(Enum):
    stripe = 'stripe'


class Customer(BaseModel):
    customer_name: Optional[constr(max_length=100)] = Field(
        None, description='The display name of the customer'
    )
    customer_id: constr(max_length=50) = Field(
        ...,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )
    email: EmailStr = Field(
        ...,
        description='The primary email address of the customer, must be the same as the email address used to create the customer in the payment provider',
    )
    payment_provider: Optional[PaymentProvider] = Field(
        None,
        description='The payment provider this customer is associated with. Currently, only Stripe is supported.',
    )
    payment_provider_id: Optional[str] = Field(
        None,
        description="The customer's ID in the specified payment provider. Please note that payment_provider and payment_provider_id are mutually necessary.",
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Extra metadata for the customer'
    )
    default_currency_code: Optional[str] = Field(
        None,
        description="The currency code this customer will be invoiced in. Codes are 3 letters, e.g. 'USD'.",
    )


class Status4(Enum):
    active = 'active'
    inactive = 'inactive'


class Success(Enum):
    none = 'none'


class CustomerBatchCreateFailure(BaseModel):
    success: Success
    failed_customers: Dict[str, Any]


class BehaviorOnExisting(Enum):
    merge = 'merge'
    ignore = 'ignore'
    overwrite = 'overwrite'


class CustomerBatchCreateRequest(BaseModel):
    customers: List[Customer]
    behavior_on_existing: BehaviorOnExisting


class Success1(Enum):
    all = 'all'
    some = 'some'


class CustomerBatchCreateSuccess(BaseModel):
    success: Success1
    failed_customers: Optional[Dict[str, Any]] = None


class CustomerUpdate(BaseModel):
    default_currency_code: str


class CustomerWithRevenue(BaseModel):
    customer_id: Optional[constr(max_length=50)] = Field(
        None,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )
    total_amount_due: float


class DayMetricUsage(BaseModel):
    date: date
    customer_usages: Dict[str, confloat(lt=10000000000.0, gt=-10000000000.0)]


class DemoRegistrationDetail(BaseModel):
    email: str
    password: str
    username: str


class DemoRegistrationFailure(BaseModel):
    detail: str


class PaymentStatus(Enum):
    draft = 'draft'


class Email(BaseModel):
    email: EmailStr


class Event(BaseModel):
    event_name: constr(max_length=100) = Field(
        ...,
        description='String name of the event, corresponds to definition in metrics',
    )
    properties: Optional[Dict[str, Any]] = Field(
        None,
        description='Extra metadata on the event that can be filtered and queried on in the metrics. All key value pairs should have string keys and values can be either strings or numbers. Place subscription filters in this object to specify which subscription the event should be tracked under',
    )
    time_created: datetime = Field(
        ...,
        description='The time that the event occured, represented as a datetime in ISO 8601 in the UTC timezome.',
    )
    idempotency_id: str = Field(
        ...,
        description='A unique identifier for the specific event being passed in. Passing in a unique id allows Lotus to make sure no double counting occurs. We recommend using a UUID4. You can use the same idempotency_id again after 7 days',
    )
    customer_id: str = Field(
        ...,
        description='The id of the customer that this event is associated with, usually the customer id in your backend',
    )


class Source(Enum):
    stripe = 'stripe'


class ExternalPlanLink(BaseModel):
    plan_id: str
    source: Source
    external_plan_id: constr(max_length=100)


class Feature(BaseModel):
    feature_name: constr(max_length=200)
    feature_description: Optional[constr(max_length=200)] = None


class Status5(Enum):
    error = 'error'


class GetCustomerEventAccessFailure(BaseModel):
    status: Status5
    detail: str


class Status6(Enum):
    error = 'error'


class GetCustomerFeatureAccessFailure(BaseModel):
    status: Status6
    detail: str


class GetFeatureAccess(BaseModel):
    feature: str = Field(..., description='Name of the feature to check access for.')
    plan_id: str = Field(
        ...,
        description='The plan_id of the plan we are checking that has access to this feature.',
    )
    subscription_filters: Dict[str, str] = Field(
        ...,
        description="The subscription filters that are applied to this plan's relationship with the customer. If your billing model does not have the ability multiple plans or subscriptions per customer, this is likely nto relevant for you.",
    )
    access: bool = Field(
        ...,
        description="Whether or not the plan has access to this feature. If your customer can have multiple plans or subscriptions, then you must check the 'access' across all returned plans to determine if the customer can access this feature.",
    )


class Status7(Enum):
    error = 'error'


class ImportCustomerFailure(BaseModel):
    status: Status7
    detail: str


class Status8(Enum):
    success = 'success'


class ImportCustomerSuccess(BaseModel):
    status: Status8
    detail: str


class Source1(Enum):
    stripe = 'stripe'


class ImportCustomersRequest(BaseModel):
    source: Source1


class Status9(Enum):
    error = 'error'


class ImportPaymentObjectFailure(BaseModel):
    status: Status9
    detail: str


class Status10(Enum):
    success = 'success'


class ImportPaymentObjectSuccess(BaseModel):
    status: Status10
    detail: str


class Source2(Enum):
    stripe = 'stripe'


class ImportPaymentObjectsRequest(BaseModel):
    source: Source2


class InitResetPasswordSuccess(BaseModel):
    email: str


class Source3(Enum):
    stripe = 'stripe'


class InitialExternalPlanLink(BaseModel):
    source: Source3
    external_plan_id: constr(max_length=100)


class FlatFeeBillingType(Enum):
    in_arrears = 'in_arrears'
    in_advance = 'in_advance'


class UsageBillingFrequencyEnum(Enum):
    monthly = 'monthly'
    quarterly = 'quarterly'
    end_of_period = 'end_of_period'
    _ = ''


class UsageBillingFrequency(BaseModel):
    __root__: Optional[UsageBillingFrequencyEnum] = None


class Status11(Enum):
    active = 'active'
    retiring = 'retiring'
    grandfathered = 'grandfathered'
    archived = 'archived'
    inactive = 'inactive'


class InviteRequest(BaseModel):
    email: EmailStr


class InviteResponse(BaseModel):
    email: EmailStr


class PaymentStatus1(Enum):
    draft = 'draft'
    voided = 'voided'
    paid = 'paid'
    unpaid = 'unpaid'


class ExternalPaymentObjType(Enum):
    stripe = 'stripe'


class BillingTypeEnum(Enum):
    in_arrears = 'in_arrears'
    in_advance = 'in_advance'
    _ = ''


class BillingType(BaseModel):
    __root__: Optional[BillingTypeEnum] = None


class PaymentStatus2(Enum):
    paid = 'paid'
    unpaid = 'unpaid'


class InvoiceUpdate(BaseModel):
    payment_status: PaymentStatus2


class PaymentStatus3(Enum):
    draft = 'draft'
    voided = 'voided'
    paid = 'paid'
    unpaid = 'unpaid'


class ExternalPaymentObjType1(Enum):
    stripe = 'stripe'


class BillingType1Enum(Enum):
    in_arrears = 'in_arrears'
    in_advance = 'in_advance'
    _ = ''


class BillingType1(BaseModel):
    __root__: Optional[BillingType1Enum] = None


class LightweightInvoiceLineItem(BaseModel):
    end_date: Optional[datetime] = None
    subtotal: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    billing_type: Optional[BillingType1] = None
    quantity: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    name: constr(max_length=200)
    metadata: Optional[Dict[str, Any]] = None
    start_date: Optional[datetime] = None


class LoginFailure(BaseModel):
    detail: str


class LoginRequest(BaseModel):
    username: str
    password: str


class LogoutFailure(BaseModel):
    detail: str


class LogoutSuccess(BaseModel):
    detail: str


class UsageAggregationType(Enum):
    count = 'count'
    sum = 'sum'
    max = 'max'
    unique = 'unique'
    latest = 'latest'
    average = 'average'


class BillableAggregationTypeEnum(Enum):
    count = 'count'
    sum = 'sum'
    max = 'max'
    unique = 'unique'
    latest = 'latest'
    average = 'average'
    _ = ''


class BillableAggregationType(BaseModel):
    __root__: Optional[BillableAggregationTypeEnum] = None


class Granularity(Enum):
    seconds = 'seconds'
    minutes = 'minutes'
    hours = 'hours'
    days = 'days'
    months = 'months'
    quarters = 'quarters'
    years = 'years'
    total = 'total'


class EventType(Enum):
    delta = 'delta'
    total = 'total'


class MetricType(Enum):
    counter = 'counter'
    stateful = 'stateful'
    rate = 'rate'


class MetricDetail(BaseModel):
    metric_name: str = Field(..., description='The name of the metric.')
    metric_id: str = Field(
        ...,
        description="The metric_id of the metric. This metric_id can be found in the Lotus frontend if you haven't seen it before.",
    )
    metric_usage: float = Field(
        ...,
        description='The current usage of the metric. Keep in mind the current usage of the metric can be different from the billable usage of the metric.',
    )
    metric_free_limit: float = Field(
        ...,
        description='If you specified a free tier of usage for this metric, this is the amount of usage that is free. Will be null if you did not specify a free tier for this metric.',
    )
    metric_total_limit: float = Field(
        ...,
        description='The total limit of the metric. Will be null if you did not specify a limit for this metric.',
    )


class MetricRevenue(BaseModel):
    metric_name: str
    original_plan_revenue: float
    new_plan_revenue: float


class Status12(Enum):
    active = 'active'
    archived = 'archived'


class MetricUpdate(BaseModel):
    billable_metric_name: Optional[constr(max_length=200)] = None
    status: Optional[Status12] = None


class Operator1(Enum):
    gte = 'gte'
    gt = 'gt'
    eq = 'eq'
    lt = 'lt'
    lte = 'lte'


class NumericFilter(BaseModel):
    property_name: constr(max_length=100)
    operator: Operator1
    comparison_value: float


class PaymentPlan(Enum):
    self_hosted_free = 'self_hosted_free'
    cloud = 'cloud'
    self_hosted_enterprise = 'self_hosted_enterprise'


class OrganizationSetting(BaseModel):
    setting_id: str
    setting_name: str
    setting_value: constr(max_length=100)
    setting_group: str


class OrganizationUpdate(BaseModel):
    default_currency_code: str


class Status13(Enum):
    Active = 'Active'
    Invited = 'Invited'


class OrganizationUser(BaseModel):
    username: constr(regex=r'^[\w.@+-]+$', max_length=150) = Field(
        ...,
        description='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.',
    )
    email: EmailStr
    role: str
    status: Optional[Status13] = 'Active'


class PaginatedActionList(BaseModel):
    next: Optional[str] = None
    previous: Optional[str] = None
    results: Optional[List[Action]] = None


class PaginatedEventList(BaseModel):
    next: Optional[str] = None
    previous: Optional[str] = None
    results: Optional[List[Event]] = None


class PatchedCustomerUpdate(BaseModel):
    default_currency_code: Optional[str] = None


class PaymentStatus4(Enum):
    paid = 'paid'
    unpaid = 'unpaid'


class PatchedInvoiceUpdate(BaseModel):
    payment_status: Optional[PaymentStatus4] = None


class Status14(Enum):
    active = 'active'
    archived = 'archived'


class PatchedMetricUpdate(BaseModel):
    billable_metric_name: Optional[constr(max_length=200)] = None
    status: Optional[Status14] = None


class PatchedOrganizationSetting(BaseModel):
    setting_id: Optional[str] = None
    setting_name: Optional[str] = None
    setting_value: Optional[constr(max_length=100)] = None
    setting_group: Optional[str] = None


class PatchedOrganizationUpdate(BaseModel):
    default_currency_code: Optional[str] = None


class Status15(Enum):
    active = 'active'
    archived = 'archived'


class PatchedPlanUpdate(BaseModel):
    plan_name: Optional[constr(max_length=100)] = Field(
        None, description='Name of the plan'
    )
    status: Optional[Status15] = None


class Status16(Enum):
    active = 'active'
    archived = 'archived'


class MakeActiveType(Enum):
    replace_immediately = 'replace_immediately'
    replace_on_active_version_renewal = 'replace_on_active_version_renewal'
    grandfather_active = 'grandfather_active'


class ReplaceImmediatelyType(Enum):
    end_current_subscription_and_bill = 'end_current_subscription_and_bill'
    end_current_subscription_dont_bill = 'end_current_subscription_dont_bill'
    change_subscription_plan = 'change_subscription_plan'


class PatchedPlanVersionUpdate(BaseModel):
    description: Optional[constr(max_length=200)] = None
    status: Optional[Status16] = None
    make_active_type: Optional[MakeActiveType] = None
    replace_immediately_type: Optional[ReplaceImmediatelyType] = None
    transition_to_plan_id: Optional[str] = None


class TriggersInEnum(Enum):
    invoice_created = 'invoice.created'
    invoice_paid = 'invoice.paid'


class PaymentProcessor(Enum):
    stripe = 'stripe'


class PaymentProviderPostData(BaseModel):
    payment_processor: PaymentProcessor
    data: Dict[str, Any]


class PaymentProviderPostRequest(BaseModel):
    pp_info: PaymentProviderPostData


class PaymentProcessor1(Enum):
    stripe = 'stripe'


class PaymentProviderPostResponse(BaseModel):
    payment_processor: PaymentProcessor1
    success: bool
    details: str


class PeriodMetricRevenueResponse(BaseModel):
    total_revenue_period_1: confloat(lt=10000000000.0, gt=-10000000000.0)
    total_revenue_period_2: confloat(lt=10000000000.0, gt=-10000000000.0)
    earned_revenue_period_1: confloat(lt=10000000000.0, gt=-10000000000.0)
    earned_revenue_period_2: confloat(lt=10000000000.0, gt=-10000000000.0)


class PeriodSingleMetricUsage(BaseModel):
    data: List[DayMetricUsage]
    total_usage: confloat(lt=10000000000.0, gt=-10000000000.0)


class PeriodSubscriptionsResponse(BaseModel):
    period_1_total_subscriptions: int
    period_1_new_subscriptions: int
    period_2_total_subscriptions: int
    period_2_new_subscriptions: int


class PlanDuration(Enum):
    monthly = 'monthly'
    quarterly = 'quarterly'
    yearly = 'yearly'


class Status17(Enum):
    active = 'active'
    archived = 'archived'
    experimental = 'experimental'


class ProrationGranularity(Enum):
    seconds = 'seconds'
    minutes = 'minutes'
    hours = 'hours'
    days = 'days'
    months = 'months'
    quarters = 'quarters'
    years = 'years'
    total = 'total'


class PlanNameAndID(BaseModel):
    plan_name: constr(max_length=100) = Field(..., description='Name of the plan')
    plan_id: Optional[constr(max_length=100)] = None


class PlanNameIDVersion(BaseModel):
    plan_name: str
    plan_id: str
    version: conint(ge=0, le=32767)


class PlanRepresentation(BaseModel):
    plan_name: str
    plan_id: str
    plan_revenue: float


class Status18(Enum):
    active = 'active'
    archived = 'archived'


class PlanUpdate(BaseModel):
    plan_name: constr(max_length=100) = Field(..., description='Name of the plan')
    status: Status18


class FlatFeeBillingType1(Enum):
    in_arrears = 'in_arrears'
    in_advance = 'in_advance'


class UsageBillingFrequency1Enum(Enum):
    monthly = 'monthly'
    quarterly = 'quarterly'
    end_of_period = 'end_of_period'
    _ = ''


class UsageBillingFrequency1(BaseModel):
    __root__: Optional[UsageBillingFrequency1Enum] = None


class Status19(Enum):
    active = 'active'
    retiring = 'retiring'
    grandfathered = 'grandfathered'
    archived = 'archived'
    inactive = 'inactive'


class Status20(Enum):
    active = 'active'
    archived = 'archived'


class MakeActiveType1(Enum):
    replace_immediately = 'replace_immediately'
    replace_on_active_version_renewal = 'replace_on_active_version_renewal'
    grandfather_active = 'grandfather_active'


class ReplaceImmediatelyType1(Enum):
    end_current_subscription_and_bill = 'end_current_subscription_and_bill'
    end_current_subscription_dont_bill = 'end_current_subscription_dont_bill'
    change_subscription_plan = 'change_subscription_plan'


class PlanVersionUpdate(BaseModel):
    description: Optional[constr(max_length=200)] = None
    status: Optional[Status20] = None
    make_active_type: Optional[MakeActiveType1] = None
    replace_immediately_type: Optional[ReplaceImmediatelyType1] = None
    transition_to_plan_id: Optional[str] = None


class Status21(Enum):
    success = 'success'


class PriceAdjustmentType(Enum):
    percentage = 'percentage'
    fixed = 'fixed'
    price_override = 'price_override'


class PriceAdjustment(BaseModel):
    price_adjustment_name: Optional[str] = ''
    price_adjustment_description: Optional[constr(max_length=200)] = None
    price_adjustment_type: PriceAdjustmentType
    price_adjustment_amount: confloat(lt=10000000000.0, gt=-10000000000.0)


class Type(Enum):
    flat = 'flat'
    per_unit = 'per_unit'
    free = 'free'


class BatchRoundingTypeEnum(Enum):
    round_up = 'round_up'
    round_down = 'round_down'
    round_nearest = 'round_nearest'
    no_rounding = 'no_rounding'
    _ = ''


class BatchRoundingType(BaseModel):
    __root__: Optional[BatchRoundingTypeEnum] = None


class PriceTier(BaseModel):
    type: Type
    range_start: confloat(lt=10000000000.0, gt=-10000000000.0)
    range_end: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    cost_per_batch: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    metric_units_per_batch: Optional[
        confloat(lt=10000000000.0, gt=-10000000000.0)
    ] = None
    batch_rounding_type: Optional[BatchRoundingType] = None


class PricingUnit(BaseModel):
    code: constr(max_length=10)
    name: constr(max_length=100)
    symbol: constr(max_length=10)


class Status22(Enum):
    active = 'active'
    archived = 'archived'


class Product(BaseModel):
    name: constr(max_length=100)
    description: Optional[str] = None
    product_id: Optional[constr(max_length=100)] = None
    status: Status22


class RegistrationDetail(BaseModel):
    company_name: str
    industry: str
    email: str
    password: str
    username: str


class RegistrationFailure(BaseModel):
    detail: str


class ResetPasswordRequest(BaseModel):
    userId: str
    password: str
    token: str


class ResetPasswordSuccess(BaseModel):
    detail: str
    token: str


class RevenueDate(BaseModel):
    date: date
    original_plan_revenue: float
    new_plan_revenue: float


class SessionSuccess(BaseModel):
    isAuthenticated: bool


class ShortCustomer(BaseModel):
    customer_name: Optional[constr(max_length=100)] = Field(
        None, description='The display name of the customer'
    )
    email: Optional[EmailStr] = Field(
        None,
        description='The primary email address of the customer, must be the same as the email address used to create the customer in the payment provider',
    )
    customer_id: Optional[constr(max_length=50)] = Field(
        None,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )


class SingleCustomerValue(BaseModel):
    customer_id: str
    customer_name: str
    value: float


class SinglePaymentProvider(BaseModel):
    payment_provider_name: str
    connected: bool
    redirect_url: AnyUrl


class SinglePlanNumCustomers(BaseModel):
    plan_name: str
    num_customers: int
    percent_total: float


class SubscriptionCategoricalFilter(BaseModel):
    value: str
    property_name: str = Field(
        ...,
        description="The string name of the property to filter on. Example: 'product_id'",
    )


class SubscriptionCustomerSummary(BaseModel):
    billing_plan_name: str
    plan_version: str
    end_date: datetime
    auto_renew: Optional[bool] = None


class SubscriptionRecord(BaseModel):
    start_date: datetime = Field(
        ...,
        description='The date the subscription starts. This should be a string in YYYY-MM-DD format of the date in UTC time.',
    )
    end_date: Optional[datetime] = Field(
        None,
        description='The date the subscription ends. This should be a string in YYYY-MM-DD format of the date in UTC time. If you donâ€™t set it (recommended), we will use the information in the billing plan to automatically calculate this.',
    )
    auto_renew: Optional[bool] = Field(
        None,
        description='Should the subscription automatically renew? defaults to true',
    )
    is_new: Optional[bool] = None
    subscription_filters: Optional[List[SubscriptionCategoricalFilter]] = Field(
        None,
        description='Add filter key, value pairs that define which events will be applied to this plan subscription',
    )
    customer_id: str = Field(
        ..., description='The id provided when creating the customer'
    )
    plan_id: str = Field(
        ..., description='The Lotus plan_id, found in the billing plan object'
    )
    customer: ShortCustomer = Field(
        ..., description='The customer object associated with this subscription.'
    )
    billing_plan: PlanNameIDVersion = Field(
        ..., description='The billing plan object associated with this subscription.'
    )


class FlatFeeBehavior(Enum):
    refund = 'refund'
    prorate = 'prorate'
    charge_full = 'charge_full'


class UsageBehavior(Enum):
    bill_full = 'bill_full'
    bill_none = 'bill_none'


class InvoicingBehavior(Enum):
    add_to_next_invoice = 'add_to_next_invoice'
    invoice_now = 'invoice_now'


class SubscriptionRecordCancel(BaseModel):
    flat_fee_behavior: Optional[FlatFeeBehavior] = Field(
        'charge_full',
        description='Can either charge the full amount of the flat fee, regardless of how long the customer has been on the plan, prorate the fflat fee, or charge nothing for the flat fee. If the flat fee has already been invoiced (e.g. in advance payment on last subscription), and the reuslting charge is less than the amount already invoiced, the difference will be refunded as a credit. Defaults to charge full amount.',
    )
    usage_behavior: Optional[UsageBehavior] = Field(
        'bill_full',
        description='If bill_full, current usage will be billed on the invoice. If bill_none, current unbilled usage will be dropped from the invoice. Defaults to bill_full.',
    )
    invoicing_behavior: Optional[InvoicingBehavior] = Field(
        'invoice_now',
        description='Whether to invoice now or invoice at the end of the billing period. Defaults to invoice now.',
    )


class InvoicingBehavior1(Enum):
    add_to_next_invoice = 'add_to_next_invoice'
    invoice_now = 'invoice_now'


class UsageBehavior1(Enum):
    transfer_to_new_subscription = 'transfer_to_new_subscription'
    keep_separate = 'keep_separate'


class SubscriptionRecordUpdate(BaseModel):
    replace_plan_id: Optional[str] = Field(
        None, description='The plan to replace the current plan with'
    )
    invoicing_behavior: Optional[InvoicingBehavior1] = Field(
        'invoice_now',
        description='The invoicing behavior to use when replacing the plan. Invoice now will invoice the customer for the prorated difference of the old plan and the new plan, whereas add_to_next_invoice will wait until the end of the subscription to do the calculation.',
    )
    usage_behavior: Optional[UsageBehavior1] = Field(
        'transfer_to_new_subscription',
        description='The usage behavior to use when replacing the plan. Transfer to new subscription will transfer the usage from the old subscription to the new subscription, whereas reset_usage will reset the usage to 0 for the new subscription, while keeping the old usage on the old subscription and charging for that appropriately at the end of the month.',
    )
    turn_off_auto_renew: Optional[bool] = Field(
        None, description='Turn off auto renew for the subscription'
    )
    end_date: Optional[datetime] = Field(
        None, description='Change the end date for the subscription.'
    )


class TopCustomers(BaseModel):
    original_plan_revenue: List[SingleCustomerValue]
    new_plan_revenue: List[SingleCustomerValue]
    biggest_pct_increase: List[SingleCustomerValue]
    biggest_pct_decrease: List[SingleCustomerValue]


class Success2(Enum):
    none = 'none'


class TrackEventFailure(BaseModel):
    success: Success2
    failed_events: Dict[str, Any]


class Success3(Enum):
    all = 'all'
    some = 'some'


class TrackEventSuccess(BaseModel):
    success: Success3
    failed_events: Optional[Dict[str, Any]] = None


class Status23(Enum):
    error = 'error'


class TransferSubscriptionsFailure(BaseModel):
    status: Status23
    detail: str


class Source4(Enum):
    stripe = 'stripe'


class TransferSubscriptionsRequest(BaseModel):
    source: Source4
    end_now: bool


class Status24(Enum):
    success = 'success'


class TransferSubscriptionsSuccess(BaseModel):
    status: Status24
    detail: str


class User(BaseModel):
    username: constr(regex=r'^[\w.@+-]+$', max_length=150) = Field(
        ...,
        description='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.',
    )
    email: EmailStr
    company_name: str
    organization_id: str


class TriggersInEnum1(Enum):
    invoice_created = 'invoice.created'
    invoice_paid = 'invoice.paid'


class TriggerName(Enum):
    invoice_created = 'invoice.created'
    invoice_paid = 'invoice.paid'


class WebhookTrigger(BaseModel):
    trigger_name: TriggerName


class BacktestCreate(BaseModel):
    start_date: date
    end_date: date
    substitutions: List[BacktestSubstitutionMulti]
    kpis: List[Kpi]
    backtest_name: constr(max_length=100)


class BatchEvent(BaseModel):
    batch: List[Event]


class CustomerBalanceAdjustment(BaseModel):
    adjustment_id: Optional[constr(max_length=100)] = None
    customer_id: str = Field(
        ...,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )
    amount: confloat(lt=10000000000.0, gt=-10000000000.0)
    pricing_unit_code: str
    pricing_unit: PricingUnit
    description: Optional[str] = None
    effective_at: Optional[datetime] = None
    expires_at: Optional[datetime] = None
    status: Optional[Status4] = None
    parent_adjustment_id: str


class CustomerSummary(BaseModel):
    customer_name: Optional[constr(max_length=100)] = Field(
        None, description='The display name of the customer'
    )
    customer_id: Optional[constr(max_length=50)] = Field(
        None,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )
    subscriptions: List[SubscriptionCustomerSummary]


class DemoRegistration(BaseModel):
    register_: DemoRegistrationDetail = Field(..., alias='register')


class DemoRegistrationSuccess(BaseModel):
    detail: str
    token: str
    user: User


class GetEventAccess(BaseModel):
    event_name: str = Field(
        ..., description='The name of the event you are checking access for.'
    )
    plan_id: str = Field(
        ...,
        description='The plan_id of the plan we are checking that has access to this feature.',
    )
    subscription_filters: Dict[str, str] = Field(
        ...,
        description="The subscription filters that are applied to this plan's relationship with the customer. If your billing model does not have the ability multiple plans or subscriptions per customer, this is likely nto relevant for you.",
    )
    has_event: bool = Field(
        ..., description='Whether or not the plan has access to this event.'
    )
    usage_per_metric: List[MetricDetail] = Field(
        ...,
        description="The usage of each metric for this event. Since a plan can have multiple metrics that rely on the same event, this is a list of all the metrics that are used by this event. For example, you might have a metric both for the total number of transactions and the rate of transactions. If you are checking access for the 'transaction' event, this will return the usage of both the 'total_transactions' and 'transaction_rate' metrics.",
    )


class GroupedLineItem(BaseModel):
    plan_name: str
    subscription_filters: List[SubscriptionCategoricalFilter]
    subtotal: confloat(lt=100000000.0, gt=-100000000.0)
    start_date: datetime
    end_date: datetime
    sub_items: List[LightweightInvoiceLineItem]


class InvoiceLineItem(BaseModel):
    name: constr(max_length=200)
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    quantity: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    subtotal: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    billing_type: Optional[BillingType] = None
    metadata: Optional[Dict[str, Any]] = None
    plan_name: str
    subscription_filters: List[SubscriptionCategoricalFilter]


class LightweightInvoice(BaseModel):
    payment_status: PaymentStatus3
    invoice_number: Optional[constr(max_length=13)] = None
    due_date: Optional[datetime] = None
    currency: PricingUnit
    issue_date: Optional[datetime] = None
    cost_due: confloat(lt=100000000.0, gt=-100000000.0)
    external_payment_obj_type: Optional[ExternalPaymentObjType1] = None
    external_payment_obj_id: Optional[constr(max_length=200)] = None


class LoginSuccess(BaseModel):
    detail: str
    token: str
    user: User


class Metric(BaseModel):
    metric_id: str
    event_name: constr(max_length=200)
    property_name: Optional[constr(max_length=200)] = None
    usage_aggregation_type: UsageAggregationType
    billable_aggregation_type: Optional[BillableAggregationType] = None
    granularity: Optional[Granularity] = None
    event_type: Optional[EventType] = None
    metric_type: MetricType
    billable_metric_name: constr(max_length=200)
    numeric_filters: Optional[List[NumericFilter]] = None
    categorical_filters: Optional[List[CategoricalFilter]] = None
    is_cost_metric: Optional[bool] = None


class Organization(BaseModel):
    organization_id: Optional[constr(max_length=100)] = None
    company_name: constr(max_length=100)
    payment_plan: Optional[PaymentPlan] = None
    payment_provider_ids: Optional[Dict[str, Any]] = None
    users: List[OrganizationUser]
    default_currency: PricingUnit
    available_currencies: List[PricingUnit]


class PatchedWebhookEndpoint(BaseModel):
    webhook_endpoint_id: Optional[str] = None
    name: Optional[constr(max_length=100)] = None
    webhook_url: Optional[constr(max_length=300)] = None
    webhook_secret: Optional[str] = None
    triggers: Optional[List[WebhookTrigger]] = None
    triggers_in: Optional[List[TriggersInEnum]] = None


class PeriodMetricUsageResponse(BaseModel):
    metrics: Dict[str, PeriodSingleMetricUsage]


class PlanComponent(BaseModel):
    billable_metric: Metric
    tiers: List[PriceTier]
    separate_by: Optional[List[str]] = None
    proration_granularity: Optional[ProrationGranularity] = 'total'
    pricing_unit: PricingUnit


class PlanVersion(BaseModel):
    description: Optional[constr(max_length=200)] = None
    plan_id: Optional[str] = None
    flat_fee_billing_type: FlatFeeBillingType1
    flat_rate: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    components: Optional[List[PlanComponent]] = None
    features: Optional[List[Feature]] = None
    price_adjustment: Optional[PriceAdjustment] = None
    usage_billing_frequency: Optional[UsageBillingFrequency1] = None
    version: int
    active_subscriptions: int
    status: Status19
    plan_name: str
    currency: PricingUnit


class PlansByNumCustomers(BaseModel):
    results: List[SinglePlanNumCustomers]
    status: Status21


class Registration(BaseModel):
    register_: RegistrationDetail = Field(..., alias='register')


class RegistrationSuccess(BaseModel):
    detail: str
    token: str
    user: User


class SingleMetricCost(BaseModel):
    metric: Metric
    cost: confloat(lt=10000000000.0, gt=-10000000000.0)


class SingleSubstitutionResults(BaseModel):
    cumulative_revenue: List[RevenueDate]
    revenue_by_metric: List[MetricRevenue]
    top_customers: TopCustomers


class WebhookEndpoint(BaseModel):
    webhook_endpoint_id: str
    name: Optional[constr(max_length=100)] = None
    webhook_url: constr(max_length=300)
    webhook_secret: str
    triggers: List[WebhookTrigger]
    triggers_in: List[TriggersInEnum1]


class BacktestSubstitution(BaseModel):
    new_plan: PlanVersion
    original_plan: PlanVersion


class CustomerDetail(BaseModel):
    customer_id: Optional[constr(max_length=50)] = Field(
        None,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )
    email: Optional[EmailStr] = Field(
        None,
        description='The primary email address of the customer, must be the same as the email address used to create the customer in the payment provider',
    )
    customer_name: Optional[constr(max_length=100)] = Field(
        None, description='The display name of the customer'
    )
    invoices: List[LightweightInvoice]
    total_amount_due: float
    subscriptions: List[SubscriptionRecord]
    integrations: Dict[str, Any] = Field(
        ...,
        description="A dictionary containing the customer's integrations. Keys are the integration type, and the value is a dictionary containing the integration's properties, which can vary by integration.",
    )
    default_currency: PricingUnit


class DraftInvoice(BaseModel):
    payment_status: PaymentStatus
    due_date: Optional[datetime] = None
    customer: ShortCustomer
    org_connected_to_cust_payment_provider: Optional[bool] = None
    currency: PricingUnit
    line_items: List[GroupedLineItem]
    issue_date: Optional[datetime] = None
    cost_due: confloat(lt=100000000.0, gt=-100000000.0)
    cust_connected_to_payment_provider: Optional[bool] = None


class DraftInvoiceResponse(BaseModel):
    invoice: Optional[List[DraftInvoice]] = None


class InitialPlanVersion(BaseModel):
    features: Optional[List[Feature]] = None
    version: int
    currency_code: Optional[str] = None
    day_anchor: Optional[conint(ge=1, le=31)] = None
    flat_fee_billing_type: FlatFeeBillingType
    currency: PricingUnit
    plan_name: str
    replace_with: int
    transition_to_plan_id: Optional[str] = None
    flat_rate: Optional[confloat(lt=10000000000.0, gt=-10000000000.0)] = None
    usage_billing_frequency: Optional[UsageBillingFrequency] = None
    active_subscriptions: int
    description: Optional[constr(max_length=200)] = None
    components: Optional[List[PlanComponent]] = None
    price_adjustment: Optional[PriceAdjustment] = None
    status: Status11
    transition_to: str
    month_anchor: Optional[conint(ge=1, le=12)] = None


class Invoice(BaseModel):
    invoice_number: Optional[constr(max_length=13)] = None
    cost_due: confloat(lt=100000000.0, gt=-100000000.0)
    currency: PricingUnit
    issue_date: Optional[datetime] = None
    payment_status: PaymentStatus1
    cust_connected_to_payment_provider: Optional[bool] = None
    org_connected_to_cust_payment_provider: Optional[bool] = None
    external_payment_obj_id: Optional[constr(max_length=200)] = None
    external_payment_obj_type: ExternalPaymentObjType
    line_items: List[InvoiceLineItem]
    customer: ShortCustomer
    due_date: Optional[datetime] = None


class Plan(BaseModel):
    plan_name: constr(max_length=100) = Field(..., description='Name of the plan')
    plan_duration: PlanDuration = Field(..., description='Duration of the plan')
    status: Status17
    external_links: List[InitialExternalPlanLink] = Field(
        ..., description='The external links that this plan has.'
    )
    plan_id: str
    parent_plan: Optional[PlanNameAndID] = Field(
        None,
        description='If you are using our plan templating feature to create a new plan, this field will be set to the plan that you are using as a template.',
    )
    target_customer: Optional[ShortCustomer] = Field(
        None,
        description='If you are using our plan templating feature to create a new plan, this field will be set to the customer for which this plan is designed for. Keep in mind that this field and the parent_plan field are mutually necessary.',
    )
    display_version: PlanVersion = Field(
        ...,
        description='The currently active version of the plan. Customers that get signed up for this plan will be assigned this version.',
    )
    num_versions: int = Field(
        ..., description='The number of versions that this plan has.'
    )
    active_subscriptions: int = Field(
        ...,
        description='The number of active subscriptions that this plan has across all versions.',
    )
    initial_external_links: Optional[List[InitialExternalPlanLink]] = None
    initial_version: InitialPlanVersion
    parent_plan_id: Optional[str] = None
    target_customer_id: Optional[str] = Field(
        None,
        description='The id provided when creating the customer, we suggest matching with your internal customer id in your backend',
    )


class SingleDayCostAnalysis(BaseModel):
    date: date
    cost_data: List[SingleMetricCost]
    revenue: confloat(lt=10000000000.0, gt=-10000000000.0)


class SingleSubstitution(BaseModel):
    substitution_name: str
    original_plan: PlanRepresentation
    new_plan: PlanRepresentation
    pct_revenue_change: float
    results: SingleSubstitutionResults


class AllSubstitutionResults(BaseModel):
    substitution_results: Optional[List[SingleSubstitution]] = None
    original_plans_revenue: Optional[float] = None
    new_plans_revenue: Optional[float] = None
    pct_revenue_change: Optional[float] = None


class BacktestDetail(BaseModel):
    backtest_name: constr(max_length=100)
    start_date: date
    end_date: date
    time_created: Optional[datetime] = None
    kpis: Optional[Dict[str, Any]] = None
    status: Optional[Status] = None
    backtest_id: Optional[constr(max_length=100)] = None
    backtest_substitutions: List[BacktestSubstitution]
    backtest_results: AllSubstitutionResults


class CostAnalysis(BaseModel):
    per_day: List[SingleDayCostAnalysis]
    total_cost: confloat(lt=10000000000.0, gt=-10000000000.0)
    total_revenue: confloat(lt=10000000000.0, gt=-10000000000.0)
    margin: confloat(lt=10000000000.0, gt=-10000000000.0)
